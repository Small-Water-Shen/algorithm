package algorithm;

import java.awt.AWTException;

/**
 * @author 沈小水
 *
 *标题：生命游戏
	
	康威生命游戏是英国数学家约翰・何顿・康威在1970年发明的细胞自动机。  
	这个游戏在一个无限大的2D网格上进行。
	
	初始时，每个小方格中居住着一个活着或死了的细胞。
	下一时刻每个细胞的状态都由它周围八个格子的细胞状态决定。
	
	具体来说：
	
	1. 当前细胞为存活状态时，当周围低于2个（不包含2个）存活细胞时， 该细胞变成死亡状态。（模拟生命数量稀少）
	2. 当前细胞为存活状态时，当周围有2个或3个存活细胞时， 该细胞保持原样。
	3. 当前细胞为存活状态时，当周围有3个以上的存活细胞时，该细胞变成死亡状态。（模拟生命数量过多）
	4. 当前细胞为死亡状态时，当周围有3个存活细胞时，该细胞变成存活状态。 （模拟繁殖）
	
	当前代所有细胞同时被以上规则处理后, 可以得到下一代细胞图。按规则继续处理这一代的细胞图，可以得到再下一代的细胞图，周而复始。
	
	例如假设初始是:(X代表活细胞，.代表死细胞)
	.....
	.....
	.XXX.
	.....
	
	下一代会变为:
	.....
	..X..
	..X..
	..X..
	.....
	
	康威生命游戏中会出现一些有趣的模式。例如稳定不变的模式：
	
	....
	.XX.
	.XX.
	....
	
	还有会循环的模式：
	
	......      ......       ......
	.XX...      .XX...       .XX...
	.XX...      .X....       .XX...
	...XX.   -> ....X.  ->   ...XX.
	...XX.      ...XX.       ...XX.
	......      ......       ......
	
	
	本题中我们要讨论的是一个非常特殊的模式，被称作"Gosper glider gun"：
	
	......................................
	.........................X............
	.......................X.X............
	.............XX......XX............XX.
	............X...X....XX............XX.
	.XX........X.....X...XX...............
	.XX........X...X.XX....X.X............
	...........X.....X.......X............
	............X...X.....................
	.............XX.......................
	......................................
	
	假设以上初始状态是第0代，请问第1000000000(十亿)代一共有多少活着的细胞？
	
	注意：我们假定细胞机在无限的2D网格上推演，并非只有题目中画出的那点空间。
	当然，对于遥远的位置，其初始状态一概为死细胞。
 */


public class 生命游戏 {
	
	static int [][] map = {
			{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 , 0, 0, 0, 0, 0, 0, 0,0 ,0 ,0 ,0 ,0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 , 0, 0, 0, 0},
			{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 , 0, 0, 0, 0, 0, 0, 0,0 ,0 ,0 ,0 ,0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0 , 0, 0, 0, 0},
			{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 , 0, 0, 0, 0, 0, 0, 0,0 ,0 ,0 ,0 ,1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0 , 0, 0, 0, 0},
			{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 , 0, 1, 1, 0, 0, 0, 0,0 ,0 ,1 ,1 ,0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 , 0, 1, 1, 0},
			{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 , 1, 0, 0, 0, 1, 0, 0,0 ,0 ,1 ,1 ,0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 , 0, 1, 1, 0},
			{0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1 , 0, 0, 0, 0, 0, 1, 0,0 ,0 ,1 ,1 ,0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 , 0, 0, 0, 0},
			{0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1 , 0, 0, 0, 1, 0, 1, 1,0 ,0 ,0 ,0 ,1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0 , 0, 0, 0, 0},
			{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1 , 0, 0, 0, 0, 0, 1, 0,0 ,0 ,0 ,0 ,0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0 , 0, 0, 0, 0},
			{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 , 1, 0, 0, 0, 1, 0, 0,0 ,0 ,0 ,0 ,0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 , 0, 0, 0, 0},
			{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 , 0, 1, 1, 0, 0, 0, 0,0 ,0 ,0 ,0 ,0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 , 0, 0, 0, 0},
			{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 , 0, 0, 0, 0, 0, 0, 0,0 ,0 ,0 ,0 ,0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 , 0, 0, 0, 0},
			{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 , 0, 0, 0, 0, 0, 0, 0,0 ,0 ,0 ,0 ,0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 , 0, 0, 0, 0},
			{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 , 0, 0, 0, 0, 0, 0, 0,0 ,0 ,0 ,0 ,0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 , 0, 0, 0, 0},
			{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 , 0, 0, 0, 0, 0, 0, 0,0 ,0 ,0 ,0 ,0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 , 0, 0, 0, 0},			
			{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 , 0, 0, 0, 0, 0, 0, 0,0 ,0 ,0 ,0 ,0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 , 0, 0, 0, 0},			
			{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 , 0, 0, 0, 0, 0, 0, 0,0 ,0 ,0 ,0 ,0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 , 0, 0, 0, 0},			
			{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 , 0, 0, 0, 0, 0, 0, 0,0 ,0 ,0 ,0 ,0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 , 0, 0, 0, 0},			
	};
	static int [][] temp;
	
	public static void print(){
		for(int i=0;i<map.length;i++){
			for(int j=0;j<map[i].length;j++){
				if(map[i][j] == 0)
					System.out.print('.');
				else{
					System.out.print('*');//■
				}
			}
			System.out.println();
		}
	}
	
	public static int sum(){
		int count = 0;
		for(int i=0;i<map.length;i++){
			for(int j=0;j<map[i].length;j++){
				if(map[i][j] == 1){
					count++;
				}
			}
		}
		return count;
	}
	
	public static int neighbor(int x, int y){
		int count = 0;
		if(x-1<0 || y-1<0 || x+1>=map.length || y+1>=map[0].length){
			return count;
		}
		if(map[x+1][y] == 1){
			count++;
		}
		if(map[x-1][y] == 1){
			count++;
		}
		if(map[x][y+1] == 1){
			count++;
		}
		if(map[x][y-1] == 1){
			count++;
		}
		if(map[x+1][y+1] == 1){
			count++;
		}
		if(map[x+1][y-1] == 1){
			count++;
		}
		if(map[x-1][y+1] == 1){
			count++;
		}
		if(map[x-1][y-1] == 1){
			count++;
		}
		return count;
	}

	public static void updata() {
		//申请临时数组
		temp = new int [map.length][map[0].length];
		for(int i=0;i<map.length;i++){
			for(int j=0;j<map[i].length;j++){
				temp[i][j] = map[i][j];
			}
		}
		//按照规则更新
		for(int i=0;i<map.length;i++){
			for(int j=0;j<map[i].length;j++){
				int neighbor = neighbor(i, j);
				//1. 当前细胞为存活状态时，当周围低于2个（不包含2个）存活细胞时， 该细胞变成死亡状态。（模拟生命数量稀少）
				if(map[i][j] == 1 && neighbor < 2){
					temp[i][j] = 0;
				}
				//2. 当前细胞为存活状态时，当周围有2个或3个存活细胞时， 该细胞保持原样。
				if(map[i][j] == 1 && (neighbor == 2 || neighbor == 3)){
					temp[i][j] = 1;
				}
				//3. 当前细胞为存活状态时，当周围有3个以上的存活细胞时，该细胞变成死亡状态。（模拟生命数量过多）
				if(map[i][j] == 1 && neighbor > 3){
					temp[i][j] = 0;
				}
				//4. 当前细胞为死亡状态时，当周围有3个存活细胞时，该细胞变成存活状态。 （模拟繁殖）
				if(map[i][j] == 0 && neighbor == 3){
					
					temp[i][j] = 1;
				}
			}
		}
		//更新到map
		for(int i=0;i<map.length;i++){
			for(int j=0;j<map[i].length;j++){
				map[i][j] = temp[i][j];
			}
		}
		print();
	}
	
	public static void main(String[] args) throws InterruptedException, AWTException {
		// TODO Auto-generated method stub
		/*int count;
		count = sum();
		for(int i = 0;i <= 100;i++){
			updata();
			System.out.println(sum()-count);
			count = sum();
		}*/
		//以上输出得出规律每一代变化之后比起前一代，活细胞数量的变化
		//3 4 5 3 -7 7 -3 13 -19 6 2 4 1 1 -14 2 3 6 1 0 0 -5 11 -17 7 -3 0 3 -2 -7 (30个)
		int sum = 3+4+5+3-7+7-3+13-19+6+2+4+1+1-14+2+3+6+1+0+0-5+11-17+7-3+0+3-2-7;
		System.out.println((1000000000/30)*sum+3);//1000000000%30=1
	}
	
}
