package algorithm;

/**
 * 加法变乘法

我们都知道：1+2+3+ ... + 49 = 1225
现在要求你把其中两个不相邻的加号变成乘号，使得结果为2015

比如：
1+2+3+...+10*11+12+...+27*28+29+...+49 = 2015
就是符合要求的答案。

请你寻找另外一个可能的答案，并把位置靠前的那个乘号左边的数字提交（对于示例，就是提交10）。
 *
 */
public class 加法变乘法 {

	public static void main(String [] args){
		
		int sum = 0;
		for(int i=1;i<48;i++){//最多到48-2的位置
			for(int j=i+2;j<50;j++){//两个不相邻的加号，所以从i+2开始
				sum = 1225 - i - (i+1) - j - (j+1);//用总和减掉4个相乘的数
				if(sum+i*(i+1)+j*(j+1)==2015){//余下的和加上4个相乘的数之和
					System.out.println(i+" "+j);
				}
			}
		}
		/*
		//一共48个加号，选两个变成乘号
		int [] a = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20
				, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38
				, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49};
		//48个加号
		for(int i=1;i<=48-2;i++){//最多到a下标为[48-2]的位置
			for(int j=i+2;j<=48;j++){//两个不相邻的加号，所以从i+2开始
				int sum1 = 0;
				int sum2 = 0;
				int sum3 = 0;
				int d1 = a[i-1]*a[i];//计算第1个乘号
				int d2 = a[j-1]*a[j];//计算第2个乘号
				//计算第1部分,1+2+3+...+10*11+...
				for(int o1=0;o1<i-1;o1++){
					sum1 += a[o1];
				}
				//计算第2部分,10*11+12+13+...+25+26+27*28+...
				for(int o2=i+1;o2<j-1;o2++){
					sum2 += a[o2];
				}
				//计算第3部分,27*28+29+30+...
				for(int o3=j+1;o3<49;o3++){
					sum3 += a[o3];
				}
				if(d1+d2+sum1+sum2+sum3 == 2015){
					System.out.println(a[i-1]);//位置靠前的那个乘号左边的数字
				//	System.out.println(a[i-1]+" "+a[j-1]);
				}
			}
		}
		*/	
	}
}
