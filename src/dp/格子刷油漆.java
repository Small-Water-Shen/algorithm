package dp;

import java.util.Scanner;

public class 格子刷油漆 {

	final static int M = 1000000007;
	/*
	 * 思路：分为四种情况
	 * 
	 * 第一种，先在第一列刷一个，然后跑到第二列刷一个，再回到第一列将第一列剩下那个刷完，最后走到第二列刷完第二列。
	 * 		    这样到第三列就是重新开始了。
	 * 第二种，先在第一列刷一个，然后跑到第二列刷一个，再到第三列挑一个来刷，这时候不能回头，因为一回头就不能刷后面的格子了
	 * 		  所以要一直走到最后一列再返回头刷。这样就是dp2[n] = 2^n种,由数组dp2[n] = 2 * dp2[n-1]递推得出。
	 * 第三种，先在第一列刷一个，然后跑到第二列刷满，这样就会造成刷不满的情况，但是列数是2的时候符合
	 * 		    由于列数是2时可以是第二种情况，所以第三种情况舍去。
	 * 第四种，很简单，先刷完第一列，再走到第二列，相当于重新刷了。
	 * 
	 * 综上。
	 * dp2就表示第二种情况，而dp1就表示所有的种数
	 * 
	 * dp1从简单的情况开始看：
	 * 	    1.对应的第四种情况，从第一列到第二列有两种走法，所以dp1[n] = 2 * dp1[n-1]
	 * 	    2.对应的第一种情况，画个2*2图，发现画完第二列有2种，然后从第二列到第三列有2种走法，
	 * 		    所以dp1[n] = 4 * dp1[n-1]
	 * 		3.对应的第二种情况，也就是dp2[n]
	 * 所以，dp1[n] = 2 * dp1[n-1] + dp2[n] + 4 * dp1[n-1]
	 * 由于有四个角，所以总数 = 4 * dp1[n]
	 * 
	 * 假如不从四个角开始刷，从中间开始的话，肯定不能将开始那一列刷满，因为会造成无法刷满，
	 * 所以就先刷出发点的左半边，再刷右半边.
	 * 选择从左边还是右边刷，有两种选择，选择出发点时，有上、下两种选择，而开始刷左、右半边时，也有两种出发的方法。
	 * 一共就是 ×8
	 * 得递推公式：(2*(2*dp2[i-1]*2*dp1[n-i])) + (2*(2*dp2[n-i]*2*dp1[i-1]))
	 * */
	public static void DP(int n){
		//dp1表示从一个角出发刷玩全部格子的种数
		long [] dp1 = new long [n+1];
		//dp2表示直接前往下一列的种数
		long [] dp2 = new long [n+1];
		//总数
		long sum = 0;
		if(n==1){
			sum = 2;
			System.out.println(sum);
			return;
		}
		//递推dp2
		dp2[1] = 1; 
		for(int i=2;i<=n;i++){
			dp2[i] = (2 * dp2[i-1]) % M;
		}
		//下面开始推dp1
		dp1[1] = 1;
		dp1[2] = 6;
		for(int i=3;i<=n;i++){
			dp1[i] = (2 * dp1[i-1] + dp2[i] + 4 * dp1[i-2]) % M;
		}
		//四个角
		sum  += (4 * dp1[n]) % M;
		//递推从中间出发
		for(int i=2;i<=n;i++){
			sum += ((8*dp1[n-i]*dp2[i-1])%M + (8*dp1[i-1]*dp2[n-i])%M) % M;
			sum = sum % M;
		}
		System.out.println(sum);
	}
	public static void main(String[] args) {
		Scanner input = new Scanner(System.in);
		int n = input.nextInt();
		DP(n);
		input.close();
	}
}
